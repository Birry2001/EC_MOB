#pragma once

#include <aslam/cameras.hpp>

#include "wrappers/Calibrator.hpp"

#include <dv-processing/camera/calibration_set.hpp>
#include <dv-processing/core/multi_stream_slicer.hpp>
#include <dv-processing/io/mono_camera_recording.hpp>
#include <dv-processing/io/mono_camera_writer.hpp>

#include <boost/property_tree/json_parser.hpp>

#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <regex>
#include <string>
#include <thread>

namespace fs = std::filesystem;
using namespace boost::property_tree;

/**
 * These functions are designed to run on a specific folder structure:
 * - The main folder contains all different device folders, as follows:
 * 		- recordings
 * 			|-- davis
 * 			|-- dvx-micro
 * 			|-- dvxplorer
 * - Each device folder contains multiple pattern folders, for example:
 * 	   - dvxplorer
 * 			|-- april-tag-0.5m
 * 			|-- april-tag-1m
 * 			|-- april-tag-3m
 * 			|-- april-tag-5m
 * 			|-- asymmetric-grid-0.5m
 * 			|-- checkerboard-0.5m
 * - Each pattern folder contains 1. a json file to describe the pattern, 2. multiple recordings folders, for example:
 * 	   - april-tag-0.5m
 * 			|-- april-tag-0.5m.json
 * 			|-- rec1
 * 			|-- rec2
 * 			|-- rec3
 * - Each recording folder contains 1. the original event file, 2. a `reconstructed` folder with all different frames
 * files from the different image reconstruction methods, for example:
 * 	   - rec1
 * 			|-- april_0.5m-2023_11_24_12_14_02.aedat4
 * 			|-- reconstructed
 * 					|-- E2VID+_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- FireNet+_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- SPADE-E2VID_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- E2VID_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- FireNet_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- SSL-E2VID_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- ET-Net_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- HyperE2VID_april_0.5m-2023_11_24_12_14_02.aedat4
 * 					|-- accumulator_april_0.5m-2023_11_24_12_14_02.aedat4
 */

/**
 * Runs camera calibration from a single image file (aedat4) given provided sensor and pattern info.
 * @param framesPath path to file containing frames with patterns to be detected for calibration
 * @param outputFilePath path to file where to save the calibration
 * @param patternPath path to json file containing calibration pattern information (name, shape, dimensions)
 * @param width number of pixels along the width of sensor
 * @param height number of pixels along the height of sensor
 */
void runCameraCalibration(const std::string &framesPath, const std::string &outputFilePath,
	const std::string &patternPath, const int32_t width, const int32_t height);

/**
 * Runs camera calibration from all different frame reconstructions of a single recording given provided sensor and
 * pattern info.
 * @param reconstructedPath full path to folder (ex: reconstructed) containing all different reconstruction .aedat4
 * files, each one containing the frames generated by a single method
 * @param outputFolderPath path to folder that will contain all different calibration files, each one will contain the
 * calibration obtained from a single set of frames
 * @param patternPath path to json file containing calibration pattern information (name, shape, dimensions)
 * @param width number of pixels along the width of sensor
 * @param height number of pixels along the height of sensor
 */
void runCameraCalibrationForAllMethods(const std::string &reconstructedPath, const std::string &outputFolderPath,
	const std::string &patternPath, const int32_t width, const int32_t height);

/**
 * Runs camera calibration from all different recordings from the same pattern
 * @param patternRecordingPath full path to folder (ex: april-tag-0.5m) containing multiple recordings (ex: rec1, rec2,
 * rec3) using the same pattern
 * @param outputFolderPath path to folder that will contain different calibration folders, each one will contain the
 * different calibrations obtained from a single recording
 * @param patternPath path to json file containing calibration pattern information (name, shape, dimensions)
 * @param width number of pixels along the width of sensor
 * @param height number of pixels along the height of sensor
 */
void runCameraCalibrationForAllRecordings(const std::string &patternRecordingPath, const std::string &outputFolderPath,
	const std::string &patternPath, const int32_t width, const int32_t height);

/**
 * Runs camera calibration from all different patterns
 * @param deviceRecordingPath full path to folder (ex: dvxplorer) containing multiple recordings using different
 * patterns (ex: april-tag-0.5m, asymmetric-grid-0.5m, checkerboard-0.5m)
 * @param outputFolderPath path to folder that will contain different calibration folders, each one will contain the
 * different calibrations obtained from a single pattern
 * @param width number of pixels along the width of sensor
 * @param height number of pixels along the height of sensor
 */
void runCameraCalibrationForAllPatterns(const std::string &deviceRecordingPath, const std::string &outputFolderPath,
	const int32_t width, const int32_t height);

/**
 * Runs camera calibration for all different devices
 * @param devicesFolderPath full path to folder (ex: recordings) containing multiple device folders (ex: davis,
 * dvx-micro, dvxplorer)
 * @param outputFolderPath path to folder that will contain different calibration folders, each one will contain the
 * different calibrations obtained for a single device
 */
void runCameraCalibrationForAllDevices(const std::string &devicesFolderPath, const std::string &outputFolderPath);

////////////////////////////////////////////////////////////////////////////////
/// implementation

void runCameraCalibration(const std::string &framesPath, const std::string &outputFilePath,
	const std::string &patternPath, const int32_t width, const int32_t height) {
	ptree patternTree;
	read_json(patternPath, patternTree);

	const auto patternName    = patternTree.get<std::string>("name");
	const auto numPatternRows = patternTree.get<int32_t>("rows");
	const auto numPatternCols = patternTree.get<int32_t>("cols");
	const auto markerSize     = patternTree.get<float>("size");
	const auto markerSpacing  = patternTree.get<float>("spacing");

	CalibratorUtils::PatternType patternType;
	if (patternName == "CHESSBOARD") {
		patternType = CalibratorUtils::PatternType::CHESSBOARD;
	}
	else if (patternName == "ASYMMETRIC_CIRCLES_GRID") {
		patternType = CalibratorUtils::PatternType::ASYMMETRIC_CIRCLES_GRID;
	}
	else if (patternName == "APRIL_GRID") {
		patternType = CalibratorUtils::PatternType::APRIL_GRID;
	}
	else {
		throw std::invalid_argument(
			"Pattern type name not supported, should be one of CHESSBOARD, ASYMMETRIC_CIRCLES_GRID, APRIL_GRID");
	}

	PatternInfo patternInfo(patternName, cv::Size(numPatternRows, numPatternCols), markerSize, markerSpacing);
	dv::io::MonoCameraRecording reader(framesPath);
	dv::FrameStreamSlicer slicer;

	CalibratorUtils::Options options;

	boost::circular_buffer<dv::Frame> mLeftFrames(5);
	std::optional<boost::circular_buffer<dv::Frame>> mRightFrames;

	options = CalibratorUtils::Options();
	options.cameraInitialSettings.emplace_back();
	options.cameraInitialSettings[0].imageSize = {width, height};
	options.pattern                            = patternType;
	options.cols                               = numPatternCols;
	options.rows                               = numPatternRows;
	options.spacingMeters                      = markerSize;
	options.patternSpacing                     = markerSpacing;
	options.maxIter                            = static_cast<size_t>(50);

	auto calibrator
		= Calibrator<aslam::cameras::DistortedPinholeCameraGeometry, aslam::cameras::RadialTangentialDistortion>(
			options);

	slicer.doEveryNumberOfElements(1, [&](const auto &frames) {
		// Retrieve frames, although we get one frame per slice, it is stored in the configured container

		// Process frame input
		mLeftFrames.push_back(frames.at(0));

		if (mLeftFrames.full()) {
			std::vector<CalibratorUtils::StampedImage> images;
			dv::Frame &left = mLeftFrames.front();
			if (left.image.channels() == 3) {
				cv::Mat gray;
				cv::cvtColor(left.image, gray, cv::COLOR_BGR2GRAY);
				images.emplace_back(gray, left.timestamp);
			}
			else {
				images.emplace_back(left.image, left.timestamp);
			}

			calibrator.addImages(images);

			mLeftFrames.pop_front();
		}
	});

	calibrator.startCollecting();
	while (reader.isRunning()) {
		const auto frame = reader.getNextFrame();
		if (frame.has_value()) {
			slicer.accept(*frame);
		}
	}
	calibrator.stopCollecting();

	std::cout << "Calibrating the intrinsics of the camera..." << std::endl;
	auto start = std::chrono::system_clock::now();

	auto intrinsicsResult = calibrator.calibrateCameraIntrinsics();
	auto end              = std::chrono::system_clock::now();

	std::chrono::duration<double> elapsed_seconds = end - start;
	std::time_t end_time                          = std::chrono::system_clock::to_time_t(end);
	std::cout << "Finished. Calibration took " << elapsed_seconds.count() << "s" << std::endl;

	if (!intrinsicsResult.has_value()) {
		throw dv::exceptions::RuntimeError(
			"Failed to calibrate intrinsics! Please check that the pattern was well detected on the images");
	}

	auto calibrationInfo = calibrator.getCalibrationInfo()[0];
	auto result          = intrinsicsResult->at(0);

	// SAVE CALIBRATION
	dv::camera::CalibrationSet calib;
	std::ostringstream optimizationInfo;
	optimizationInfo << "kalibr: " << calibrationInfo.numImagesUsed << " out of " << calibrationInfo.numImagesTotal
					 << " images used";
	calib.addCameraCalibration(getIntrinsicCalibrationData<aslam::cameras::RadialTangentialDistortion>(
		result, patternInfo, "left", "left", optimizationInfo.str()));

	calib.writeToFile(outputFilePath);
	std::cout << fmt::format("Calibration saved in {}", outputFilePath) << std::endl;
}

void runCameraCalibrationForAllMethods(const std::string &reconstructedPath, const std::string &outputFolderPath,
	const std::string &patternPath, const int32_t width, const int32_t height) {
	if (!fs::exists(outputFolderPath)) {
		// Create directory
		fs::create_directories(outputFolderPath);
	}

	// Loop over all aedat4 files
	for (const auto &imagesFile : fs::directory_iterator(reconstructedPath)) {
		if (imagesFile.path().extension() != ".aedat4") {
			continue;
		}

		const std::string reconstructionMethodName = imagesFile.path().stem().string();

		const std::string outputFilePath = fs::path(outputFolderPath) / (reconstructionMethodName + ".json");

		std::cout << "===================================================================================" << std::endl;
		std::cout << fmt::format("Running intrinsic calibration from method {}", reconstructionMethodName) << std::endl;
		try {
			runCameraCalibration(imagesFile.path().string(), outputFilePath, patternPath, width, height);
			std::cout << fmt::format("SUCCESS: Calibration for file {}", imagesFile.path().string()) << std::endl;
		}
		catch (...) {
			std::cout << fmt::format("FAILED: Calibration for file {}", imagesFile.path().string()) << std::endl;
		}
		std::cout << "===================================================================================" << std::endl;
	}
}

void runCameraCalibrationForAllRecordings(const std::string &patternRecordingPath, const std::string &outputFolderPath,
	const std::string &patternPath, const int32_t width, const int32_t height) {
	if (!fs::exists(outputFolderPath)) {
		// Create directory
		fs::create_directories(outputFolderPath);
	}

	// Loop over all recording folders
	for (const auto &recFolder : fs::directory_iterator(patternRecordingPath)) {
		if (!fs::is_directory(recFolder)) {
			continue;
		}
		// Assumes a "reconstructed" folder exists
		const std::string recName             = recFolder.path().filename().string();
		const std::string reconstructedFolder = recFolder.path() / "reconstructed";

		if (!fs::is_directory(reconstructedFolder)) {
			std::cout << fmt::format("For recording {}, 'reconstructed' folder missing.", recName) << std::endl;
			continue;
		}

		const std::string outputRecPath = fs::path(outputFolderPath) / recName;

		std::cout << "===================================================================================" << std::endl;
		std::cout << fmt::format("Running intrinsic calibrations on recording {}", recName) << std::endl;
		runCameraCalibrationForAllMethods(reconstructedFolder, outputRecPath, patternPath, width, height);
		std::cout << "===================================================================================" << std::endl;
	}
}

void runCameraCalibrationForAllPatterns(const std::string &deviceRecordingPath, const std::string &outputFolderPath,
	const int32_t width, const int32_t height) {
	if (!fs::exists(outputFolderPath)) {
		// Create directory
		fs::create_directories(outputFolderPath);
	}

	// Loop over all pattern folders
	for (const auto &patternRecordingFolder : fs::directory_iterator(deviceRecordingPath)) {
		if (!fs::is_directory(patternRecordingFolder)) {
			continue;
		}
		// Assumes a {patternRecordingName}.json exists
		const std::string patternRecordingName = patternRecordingFolder.path().filename();
		const std::string patternPath          = patternRecordingFolder.path() / (patternRecordingName + ".json");

		if (!fs::exists(patternPath)) {
			std::cout << fmt::format(
				"For pattern folder {}, pattern file {} missing.", patternRecordingName, patternPath)
					  << std::endl;
			continue;
		}

		const std::string outputPatternRecordingPath = fs::path(outputFolderPath) / patternRecordingName;

		std::cout << "===================================================================================" << std::endl;
		std::cout << fmt::format("Running intrinsic calibrations on pattern {}", patternRecordingName) << std::endl;
		runCameraCalibrationForAllRecordings(
			patternRecordingFolder.path().string(), outputPatternRecordingPath, patternPath, width, height);
		std::cout << "===================================================================================" << std::endl;
	}
}

void runCameraCalibrationForAllDevices(const std::string &devicesFolderPath, const std::string &outputFolderPath) {
	if (!fs::exists(outputFolderPath)) {
		// Create directory
		fs::create_directories(outputFolderPath);
	}

	// Loop over all device folders
	for (const auto &deviceRecordingFolder : fs::directory_iterator(devicesFolderPath)) {
		if (!fs::is_directory(deviceRecordingFolder)) {
			continue;
		}
		// Assumes the folder is named after the device
		const std::string deviceName = deviceRecordingFolder.path().filename();
		int32_t width, height;
		if (deviceName.find("davis") != std::string::npos) {
			width  = 346;
			height = 260;
		}
		else {
			width  = 640;
			height = 480;
		}

		const std::string outputDeviceRecordingPath = fs::path(outputFolderPath) / deviceName;

		std::cout << "===================================================================================" << std::endl;
		std::cout << fmt::format("Running intrinsic calibrations on device {}", deviceName) << std::endl;
		runCameraCalibrationForAllPatterns(
			deviceRecordingFolder.path().string(), outputDeviceRecordingPath, width, height);
		std::cout << "===================================================================================" << std::endl;
	}
}
