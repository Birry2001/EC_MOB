#include <rclcpp/rclcpp.hpp>

// Standard libraries
#include <algorithm>
#include <cmath>
#include <cfloat>
#include <iostream>
#include <fstream>
#include <mutex>
#include <vector>

// ROS 2 Messages headers
#include <dvs_msgs/msg/event.hpp>
#include <dvs_msgs/msg/event_array.hpp>
#include <event_camera_msgs/msg/event_packet.hpp>

#include <sensor_msgs/msg/imu.hpp>
#include <sensor_msgs/msg/image.hpp>
#include <sensor_msgs/image_encodings.hpp>

// OpenCV headers
#include <cv_bridge/cv_bridge.h> 
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <image_transport/image_transport.hpp>

using namespace std;

using sll = long long int;


// Main Class definition

class EventVisualizer: public rclcpp::Node {

        private:
        // --- Attributes (Previously global variables) ---
        std::vector<dvs_msgs::msg::Event> event_buffer;
        std::vector<sensor_msgs::msg::Imu> imu_buffer;
        std::vector<sensor_msgs::msg::Imu> imu_buffer_; // Working buffer
        bool first_event_received = true;
        bool imu_ready = false;
        static constexpr size_t MIN_IMU_SAMPLES = 5;

        // Mutex for thread safety
        std::mutex mtx;

        // Parameter variables
        int height_;
        int weight_;
        double Focus_;
        double pixel_size_;

        //subscribers
        rclcpp::Subscription<event_camera_msgs::msg::EventPacket>::SharedPtr event_sub_;
         rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr imu_sub_;

        //publisher
        image_transport::Publisher image_pub;


        // Callbacks
        void event_cb(const event_camera_msgs::msg::EventPacket::SharedPtr msg);

        void imu_cb(const sensor_msgs::msg::Imu::SharedPtr msg);

        // Methods
        void data_process();
        void show_count_image(const std::vector<std::vector<int>> &count_image,int& max_count);






        public:
        //Constructor
        EventVisualizer() : Node("datasync_node") {
        // Simple log to verify initialization
        RCLCPP_INFO(this->get_logger(),"EventVisualizer node started successfully.");

        // Declaring parameters with default values
        this->declare_parameter<int>("weight_param", 346);
        this->declare_parameter<int>("height_param", 260);
        this->declare_parameter<double>("focus", 6550.0);
        this->declare_parameter<double>("pixel_size", 18.5);

        //Retrieve parameter values
        weight_ = this->get_parameter("weight_param").as_int();
        height_ = this->get_parameter("height_param").as_int();
        Focus_ = this->get_parameter("focus").as_double();
        pixel_size_ = this->get_parameter("pixel_size").as_double();

        // Log configuration to verify everything is correct
        RCLCPP_INFO(this->get_logger(), "Configuration loaded:");
        RCLCPP_INFO(this->get_logger(), "  - Width: %d, Height: %d", weight_, height_);
        RCLCPP_INFO(this->get_logger(), "  - Focus: %.2f, Pixel Size: %.2f", Focus_, pixel_size_);

        //subscribers
        event_sub_ = this->create_subscription<event_camera_msgs::msg::EventPacket>(
        "/event_camera/events",
        rclcpp::SensorDataQoS(),
        std::bind(&EventVisualizer::event_cb, this, std::placeholders::_1)
        );


        imu_sub_ = this->create_subscription<sensor_msgs::msg::Imu>(
                "/event_camera/imu",
                rclcpp::SensorDataQoS(),
                std::bind(&EventVisualizer::imu_cb, this, std::placeholders::_1)
        );
        
        //Image Publisher 
        image_pub = image_transport::create_publisher(this, "count_image");


        }


};

void EventVisualizer::event_cb(
    const event_camera_msgs::msg::EventPacket::SharedPtr msg)
{
    if (!imu_ready) {
        return;
    }

    if (first_event_received) {
        first_event_received = false;
        RCLCPP_INFO(this->get_logger(),
            "First event received → synchronization OK");
        return;
    }

    {
        std::lock_guard<std::mutex> lock(mtx);
        imu_buffer_ = imu_buffer;
        imu_buffer.clear();
    }

    if (imu_buffer_.empty()) {
        return;
    }

    event_buffer.clear();
    event_buffer.reserve(msg->events.size());

    for (const auto &e : msg->events) {
        dvs_msgs::msg::Event ev;
        ev.x = e.x;
        ev.y = e.y;
        ev.polarity = static_cast<bool>(e.polarity);
        ev.ts = e.ts;
        event_buffer.push_back(ev);
    }

    data_process();
}



void EventVisualizer::data_process(){


    RCLCPP_WARN(this->get_logger(),
        "[data_process] called | events=%zu | imu_working=%zu",
        event_buffer.size(),
        imu_buffer_.size()
    );

    if (event_buffer.empty()) {
        RCLCPP_WARN(this->get_logger(),
            "[data_process] EXIT: event_buffer empty");
        return;}



        if (rclcpp::Time(imu_buffer_.back().header.stamp).nanoseconds() > rclcpp::Time(event_buffer.front().ts).nanoseconds()) {
                 
                 float angular_velocity_x=0.0, angular_velocity_y=0.0,angular_velocity_z=0.0;
                 float average_angular_rate_x, average_angular_rate_y,average_angular_rate_z;

                 
                 int cnt=0;//imu counter
                 for(int i=0;i<imu_buffer_.size();++i){
                         if(rclcpp::Time(imu_buffer_[i].header.stamp).nanoseconds() >= (rclcpp::Time(event_buffer.front().ts).nanoseconds() - 3000000)){
                                 angular_velocity_x+=imu_buffer_[i].angular_velocity.x;
                                 angular_velocity_y+=imu_buffer_[i].angular_velocity.y;
                                 angular_velocity_z+=imu_buffer_[i].angular_velocity.z;
                                 cnt++;
                        }
                 
                }

                if (cnt == 0) return; 

                 //Calculate the average imu angular rates
                 average_angular_rate_x = angular_velocity_x/float(cnt);
                 average_angular_rate_y = angular_velocity_y/float(cnt);
                 average_angular_rate_z = angular_velocity_z/float(cnt);
                 float average_angular_rate = std::sqrt((average_angular_rate_x*average_angular_rate_x) + (average_angular_rate_y*average_angular_rate_y) + (average_angular_rate_z*average_angular_rate_z));

                 
                 //Motion  compensation
                 sll t0 = rclcpp::Time(event_buffer.front().ts).nanoseconds();//the first event
                 float time_diff = 0.0;//time diff
                 std::vector<std::vector<int>>count_image(height_,std::vector<int>(weight_));//count image
                 std::vector<std::vector<float>>time_image(height_,std::vector<float>(weight_));//time image
                 for(int i=0;i<event_buffer.size();++i){
                        time_diff = double(rclcpp::Time(event_buffer[i].ts).nanoseconds() - t0) / 1000000000.0;

                        //Calculate the rotation offset of the event point
                        float x_angular=time_diff*average_angular_rate_x;
                        float y_angular=time_diff*average_angular_rate_y;
                        float z_angular=time_diff*average_angular_rate_z;

                        
                        int x=event_buffer[i].x - weight_/2; 
                        int y=event_buffer[i].y - height_/2;
                        
                        //Angle of initial position of event point
                        float pre_x_angel = atan(y*pixel_size_/Focus_);
                        float pre_y_angel = atan(x*pixel_size_/Focus_);

                        //compensate
                        int compen_x = (int)((x*cos(z_angular) - sin(z_angular)*y) - (x - (Focus_*tan(pre_y_angel + y_angular)/pixel_size_)) + weight_/2);
                        int compen_y = (int)((x*sin(z_angular) + cos(z_angular)*y) - (y - (Focus_*tan(pre_x_angel - x_angular)/pixel_size_)) + height_/2);
                        event_buffer[i].x = compen_x;
                        event_buffer[i].y = compen_y;
                        
                        
                        //count image and time image
                        if(compen_y < height_ && compen_y >= 0 && compen_x < weight_ && compen_x >= 0){
                            if(count_image[compen_y][compen_x]<20)count_image[compen_y][compen_x]++; 
                            time_image[compen_y][compen_x] += time_diff;
                        }
                    }

                 int max_count = 0;
                 float max_time = 0.0;
                 float total_time = 0.0;
                 float average_time = 0.0;
                 int trigger_pixels = 0;

                 for(int i = 0; i<height_; ++i){
                        for(int j = 0; j < weight_; ++j){
                                if(count_image[i][j] != 0){
                                        time_image[i][j] /= count_image[i][j];
                                        max_count = std::max(max_count,count_image[i][j]);
                                }
                        }
                 }

                  
                 //Visualize compensated count image
                 show_count_image(count_image, max_count);  
                
                 //release buffer
                 event_buffer.clear();
                 imu_buffer_.clear();
        }else{
                 //keep safe 
                if(event_buffer.size() != 0){

                        event_buffer.clear();
                } 
                if(imu_buffer_.size() != 0){

                        imu_buffer_.clear();
                }
        }



}

void EventVisualizer::show_count_image(const std::vector<std::vector<int>>& count_image, int& max_count)
{
    using namespace cv;

    cv::Mat image(height_, weight_, CV_8UC1);

    if (max_count <= 0) {
        image.setTo(0);
    } else {
        int scale = static_cast<int>(255 / max_count) + 1;

        for (int i = 0; i < height_; ++i) {
            for (int j = 0; j < weight_; ++j) {
                image.at<uchar>(i, j) =
                    static_cast<uchar>(count_image[i][j] * scale);
            }
        }
    }

    // ROS2 equivalent of CvImage → ImageMsg
    std_msgs::msg::Header header;
    header.stamp = this->now();
    header.frame_id = "dvs_frame";

    sensor_msgs::msg::Image::SharedPtr msg =
        cv_bridge::CvImage(header, "mono8", image).toImageMsg();

    image_pub.publish(msg);
}



void EventVisualizer::imu_cb(
    const sensor_msgs::msg::Imu::SharedPtr msg)
{
    std::lock_guard<std::mutex> lock(mtx);
    imu_buffer.push_back(*msg);

    if (!imu_ready && imu_buffer.size() >= MIN_IMU_SAMPLES) {
        imu_ready = true;
        RCLCPP_INFO(this->get_logger(),
            "IMU ready (%zu samples)", imu_buffer.size());
    }
}




int main(int argc, char** argv) {
        // Initialise ROS2
        rclcpp::init(argc, argv);

        //Create the node
        auto node = std::make_shared<EventVisualizer>();

        //Spin the node
        rclcpp::spin(node);

        //shutdown ROS2
        rclcpp::shutdown();
        return 0;
}
